{
  "name": "Rust/Cargo",
  "framework": "rust",
  "version": "1.0.0",
  "description": "Rust语言项目配置模板，使用Cargo包管理器",
  
  "detection": {
    "files": ["Cargo.toml", "Cargo.lock", "main.rs", "lib.rs"],
    "directories": ["src", "tests", "target", ".cargo"],
    "build_tools": ["cargo"]
  },
  
  "test": {
    "directories": ["src", "tests", "examples", "benches"],
    "patterns": {
      "unit": ["src/**/*.rs (with #[cfg(test)])", "src/lib.rs"],
      "integration": ["tests/*.rs", "tests/**/*.rs"],
      "doc": ["src/**/*.rs (doc comments with ///)", "README.md"],
      "benchmark": ["benches/*.rs", "benches/**/*.rs"]
    },
    "frameworks": {
      "unit": ["std::test", "assert", "assert_eq", "assert_ne"],
      "integration": ["std::test", "tempfile", "serial_test"],
      "property": ["proptest", "quickcheck"],
      "mocking": ["mockall", "mockers"]
    }
  },
  
  "commands": {
    "build": {
      "debug": "cargo build",
      "release": "cargo build --release",
      "check": "cargo check",
      "clippy": "cargo clippy"
    },
    "test": {
      "all": "cargo test",
      "unit": "cargo test --lib",
      "integration": "cargo test --test '*'",
      "doc": "cargo test --doc",
      "release": "cargo test --release",
      "verbose": "cargo test -- --nocapture"
    },
    "coverage": {
      "tarpaulin": "cargo tarpaulin --out Html",
      "llvm_cov": "cargo llvm-cov --html"
    },
    "lint": {
      "clippy": "cargo clippy -- -D warnings",
      "fmt": "cargo fmt",
      "fmt_check": "cargo fmt -- --check"
    },
    "doc": {
      "build": "cargo doc",
      "open": "cargo doc --open"
    }
  },
  
  "tools": {
    "testing": {
      "std_test": {
        "attributes": ["#[test]", "#[cfg(test)]", "#[should_panic]", "#[ignore]"],
        "macros": ["assert!", "assert_eq!", "assert_ne!", "debug_assert!"],
        "result": "Result<(), Box<dyn std::error::Error>>"
      },
      "proptest": {
        "crate": "proptest = \"1.0\"",
        "usage": "属性测试，生成大量测试数据",
        "strategies": "prop::collection, prop::option"
      },
      "serial_test": {
        "crate": "serial_test = \"3.0\"",
        "attribute": "#[serial]",
        "purpose": "串行执行测试，避免并发问题"
      }
    },
    "mocking": {
      "mockall": {
        "crate": "mockall = \"0.11\"",
        "derive": "#[automock]",
        "usage": "自动生成Mock对象"
      },
      "wiremock": {
        "crate": "wiremock = \"0.5\"",
        "purpose": "HTTP服务Mock"
      }
    },
    "coverage": {
      "tarpaulin": {
        "install": "cargo install cargo-tarpaulin",
        "command": "cargo tarpaulin --out Html --out Xml"
      },
      "llvm_cov": {
        "install": "cargo install cargo-llvm-cov",
        "command": "cargo llvm-cov --html --open"
      }
    },
    "quality": {
      "clippy": "静态分析工具，检查代码问题",
      "rustfmt": "代码格式化工具",
      "cargo_audit": "安全漏洞检查",
      "cargo_outdated": "依赖版本检查"
    }
  },
  
  "structure": {
    "library": {
      "src/lib.rs": "库的根文件",
      "src/main.rs": "二进制可执行文件入口",
      "src/bin/": "额外的二进制文件",
      "tests/": "集成测试",
      "examples/": "示例代码",
      "benches/": "性能测试"
    },
    "workspace": {
      "Cargo.toml": "[workspace] 根配置",
      "members/": "成员package目录",
      "shared/": "共享代码"
    },
    "config": {
      "Cargo.toml": "项目配置文件",
      "Cargo.lock": "依赖锁定文件",
      "rust-toolchain.toml": "工具链版本锁定",
      ".cargo/config.toml": "Cargo配置"
    }
  },
  
  "tdd": {
    "red_phase": {
      "commands": ["cargo test test_name -- --exact"],
      "expectations": "测试失败，编译成功，错误信息清晰"
    },
    "green_phase": {
      "commands": ["cargo test test_name -- --exact"],
      "expectations": "最小实现让测试通过，确保类型安全"
    },
    "refactor_phase": {
      "commands": [
        "cargo test",
        "cargo clippy -- -D warnings",
        "cargo fmt -- --check",
        "cargo tarpaulin --out Html"
      ],
      "expectations": "重构代码，保持测试通过，提升代码质量"
    }
  },
  
  "quality_gates": {
    "coverage": {
      "line_coverage": 85,
      "branch_coverage": 80
    },
    "performance": {
      "compile_time": "增量编译时间 < 30s",
      "test_execution": "单元测试 < 10s"
    },
    "code_quality": {
      "clippy_warnings": 0,
      "format_violations": 0
    }
  },
  
  "best_practices": {
    "naming": {
      "test_functions": "test_开头，描述测试场景",
      "test_modules": "tests或test模块",
      "integration_tests": "文件名反映测试内容"
    },
    "structure": {
      "unit_tests": "与源码在同一文件，#[cfg(test)]模块",
      "integration_tests": "tests/目录下独立文件",
      "doc_tests": "/// 注释中的代码示例"
    },
    "error_handling": {
      "result_type": "使用Result<T, E>处理可能失败的操作",
      "panic_tests": "使用#[should_panic]测试panic情况",
      "error_messages": "提供清晰的错误信息"
    },
    "memory_safety": {
      "ownership": "充分利用所有权系统",
      "borrowing": "合理使用借用和引用",
      "lifetimes": "明确生命周期参数"
    }
  },
  
  "common_crates": {
    "testing": {
      "proptest": "proptest = \"1.0\"",
      "quickcheck": "quickcheck = \"1.0\"",
      "serial_test": "serial_test = \"3.0\"",
      "tempfile": "tempfile = \"3.0\"",
      "assert_matches": "assert_matches = \"1.5\""
    },
    "mocking": {
      "mockall": "mockall = \"0.11\"",
      "wiremock": "wiremock = \"0.5\"",
      "httptest": "httptest = \"0.15\""
    },
    "async_testing": {
      "tokio_test": "tokio-test = \"0.4\"",
      "async_std_test": "async-std = { version = \"1.0\", features = [\"attributes\"] }"
    },
    "coverage": {
      "tarpaulin": "cargo install cargo-tarpaulin",
      "llvm_cov": "cargo install cargo-llvm-cov"
    }
  },
  
  "templates": {
    "unit_test": {
      "basic": "// src/lib.rs\npub struct UserService;\n\nimpl UserService {\n    pub fn create_user(&self, email: &str, name: &str) -> Result<User, String> {\n        if email.is_empty() || name.is_empty() {\n            return Err(\"Email and name cannot be empty\".to_string());\n        }\n        Ok(User {\n            id: uuid::Uuid::new_v4().to_string(),\n            email: email.to_string(),\n            name: name.to_string(),\n        })\n    }\n}\n\n#[derive(Debug, PartialEq)]\npub struct User {\n    pub id: String,\n    pub email: String,\n    pub name: String,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_create_user_success() {\n        // Arrange\n        let user_service = UserService;\n        let email = \"test@example.com\";\n        let name = \"Test User\";\n\n        // Act\n        let result = user_service.create_user(email, name);\n\n        // Assert\n        assert!(result.is_ok());\n        let user = result.unwrap();\n        assert_eq!(user.email, email);\n        assert_eq!(user.name, name);\n        assert!(!user.id.is_empty());\n    }\n\n    #[test]\n    fn test_create_user_empty_email() {\n        // Arrange\n        let user_service = UserService;\n\n        // Act\n        let result = user_service.create_user(\"\", \"Test User\");\n\n        // Assert\n        assert!(result.is_err());\n        assert_eq!(result.unwrap_err(), \"Email and name cannot be empty\");\n    }\n}"
    },
    "integration_test": {
      "example": "// tests/integration_test.rs\nuse my_crate::UserService;\n\n#[test]\nfn test_user_service_integration() {\n    let user_service = UserService::new();\n    \n    let result = user_service.create_user(\"integration@test.com\", \"Integration Test\");\n    \n    assert!(result.is_ok());\n    let user = result.unwrap();\n    assert_eq!(user.email, \"integration@test.com\");\n}"
    },
    "property_test": {
      "proptest": "use proptest::prelude::*;\n\nproptest! {\n    #[test]\n    fn test_user_creation_properties(\n        email in \"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}\",\n        name in \"[A-Za-z ]{1,50}\"\n    ) {\n        let user_service = UserService;\n        let result = user_service.create_user(&email, &name);\n        \n        prop_assert!(result.is_ok());\n        let user = result.unwrap();\n        prop_assert_eq!(user.email, email);\n        prop_assert_eq!(user.name, name);\n        prop_assert!(!user.id.is_empty());\n    }\n}"
    },
    "mock_test": {
      "mockall": "use mockall::predicate::*;\nuse mockall::mock;\n\nmock! {\n    UserRepository {\n        fn save(&self, user: &User) -> Result<String, String>;\n    }\n}\n\n#[test]\nfn test_user_service_with_mock() {\n    // Arrange\n    let mut mock_repo = MockUserRepository::new();\n    mock_repo\n        .expect_save()\n        .with(eq(User { id: \"123\".to_string(), email: \"test@example.com\".to_string(), name: \"Test User\".to_string() }))\n        .times(1)\n        .returning(|_| Ok(\"saved-id\".to_string()));\n    \n    let user_service = UserService::new(Box::new(mock_repo));\n    \n    // Act\n    let result = user_service.create_and_save_user(\"test@example.com\", \"Test User\");\n    \n    // Assert\n    assert!(result.is_ok());\n    assert_eq!(result.unwrap(), \"saved-id\");\n}"
    }
  },
  
  "async_testing": {
    "tokio": {
      "dependency": "tokio = { version = \"1.0\", features = [\"full\"] }",
      "attribute": "#[tokio::test]",
      "example": "#[tokio::test]\nasync fn test_async_function() {\n    let result = async_function().await;\n    assert!(result.is_ok());\n}"
    },
    "async_std": {
      "dependency": "async-std = { version = \"1.0\", features = [\"attributes\"] }",
      "attribute": "#[async_std::test]",
      "example": "#[async_std::test]\nasync fn test_async_function() {\n    let result = async_function().await;\n    assert!(result.is_ok());\n}"
    }
  }\n}